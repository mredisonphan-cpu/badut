<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover"/>
  <title>B√Ä ƒê·ª§T ‚Äì Mobile iPhone Fixed</title>
  <style>
    html,body{
      margin:0;height:100%;
      background:#0c0f1f;color:#fff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      overflow:hidden;
      overscroll-behavior:none;
      -webkit-text-size-adjust:100%;
      -webkit-user-select:none;
      user-select:none;
      touch-action:none;
    }
    #wrap{position:fixed;inset:0}
    canvas{
      width:100vw;height:100vh;
      background:#11152a;
      display:block;
      touch-action:none;
    }

    /* Overlay HUD */
    #hud{
      position:fixed; inset:0;
      pointer-events:none;
      touch-action:none;
    }
    .btn{
      position:absolute;
      pointer-events:auto;
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
      touch-action:none;
      background:rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.18);
      border-bottom:2px solid rgba(255,255,255,0.10);
      color:#fff;
      font-weight:900;
      border-radius:18px;
      display:grid; place-items:center;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .btn:active{ transform: scale(0.98); background:rgba(255,122,182,0.30); }

    /* Safe-area helpers */
    :root{
      --safeT: env(safe-area-inset-top);
      --safeR: env(safe-area-inset-right);
      --safeB: env(safe-area-inset-bottom);
      --safeL: env(safe-area-inset-left);
    }

    /* Left cluster */
    #left, #right{
      width:72px;height:72px;
      bottom: calc(24px + var(--safeB));
      font-size:26px;
    }
    #left{ left:  calc(22px + var(--safeL)); }
    #right{ left: calc(108px + var(--safeL)); }

    /* Right cluster */
    #jump{
      width:94px;height:94px;
      bottom: calc(24px + var(--safeB));
      right:  calc(22px + var(--safeR));
      font-size:16px;
    }
    #slide{
      width:88px;height:70px;
      bottom: calc(132px + var(--safeB));
      right:  calc(24px + var(--safeR));
      font-size:14px;
    }
    #fart{
      width:88px;height:70px;
      bottom: calc(210px + var(--safeB));
      right:  calc(24px + var(--safeR));
      font-size:14px;
    }
    #act{
      width:88px;height:70px;
      bottom: calc(288px + var(--safeB));
      right:  calc(24px + var(--safeR));
      font-size:14px;
    }

    /* Top small buttons */
    #reset{
      width:64px;height:44px;
      top:   calc(14px + var(--safeT));
      right: calc(14px + var(--safeR));
      border-radius:14px; font-size:14px;
    }
    #sound{
      width:64px;height:44px;
      top:   calc(14px + var(--safeT));
      right: calc(86px + var(--safeR));
      border-radius:14px; font-size:14px;
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
</div>

<div id="hud">
  <div id="left"  class="btn">‚Üê</div>
  <div id="right" class="btn">‚Üí</div>

  <div id="jump" class="btn">JUMP</div>
  <div id="slide" class="btn">SLIDE</div>
  <div id="fart" class="btn">FART</div>
  <div id="act"  class="btn">WC(E)</div>

  <div id="sound" class="btn">üîä</div>
  <div id="reset" class="btn">R</div>
</div>

<script>
(() => {
  /* ========= iOS SAFARI ANTI-ZOOM / ANTI-SCROLL PATCH ========= */
  // Block pinch gestures
  ["gesturestart","gesturechange","gestureend"].forEach(evt=>{
    document.addEventListener(evt, e => e.preventDefault(), {passive:false});
  });
  // Block double-tap to zoom
  let lastTouchEnd = 0;
  document.addEventListener("touchend", (e)=>{
    const now = Date.now();
    if(now - lastTouchEnd <= 300){
      e.preventDefault();
    }
    lastTouchEnd = now;
  }, {passive:false});
  // Block page scroll/bounce
  document.addEventListener("touchmove", e => e.preventDefault(), {passive:false});

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });

  function resizeCanvas(){
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    // Draw in CSS pixels
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  addEventListener("resize", resizeCanvas, {passive:true});
  resizeCanvas();

  const W = () => window.innerWidth;
  const H = () => window.innerHeight;

  /* ===================== Utils ===================== */
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rects=(a,b)=>a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;

  function roundRect(x,y,w,h,r){
    r=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  /* ===================== Audio (needs gesture) ===================== */
  let audioOn=true, ac=null;
  function ensureAudio(){ if(!ac) ac=new (window.AudioContext||window.webkitAudioContext)(); }
  function beep(freq=440,dur=0.06,type="sine",gain=0.04){
    if(!audioOn) return;
    ensureAudio();
    if(ac.state==="suspended") ac.resume().catch(()=>{});
    const o=ac.createOscillator(), g=ac.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value=gain;
    o.connect(g); g.connect(ac.destination);
    o.start(); o.stop(ac.currentTime+dur);
  }

  /* ===================== Keyboard + Touch unify ===================== */
  const keys=new Set();
  addEventListener("keydown",(e)=>keys.add(e.key.toLowerCase()));
  addEventListener("keyup",(e)=>keys.delete(e.key.toLowerCase()));
  const down=(k)=>keys.has(k);

  const v = { left:false, right:false, jump:false, slide:false, fart:false, act:false, reset:false };

  function bindHoldBtn(id, field){
    const el=document.getElementById(id);
    const on=(e)=>{ e.preventDefault(); ensureAudio(); v[field]=true; };
    const off=(e)=>{ e.preventDefault(); v[field]=false; };
    el.addEventListener("pointerdown", on, {passive:false});
    el.addEventListener("pointerup", off, {passive:false});
    el.addEventListener("pointercancel", off, {passive:false});
    el.addEventListener("pointerleave", off, {passive:false});
  }
  bindHoldBtn("left","left");
  bindHoldBtn("right","right");
  bindHoldBtn("jump","jump");
  bindHoldBtn("slide","slide");
  bindHoldBtn("fart","fart");
  bindHoldBtn("act","act");

  const resetBtn=document.getElementById("reset");
  resetBtn.addEventListener("pointerdown",(e)=>{ e.preventDefault(); v.reset=true; }, {passive:false});
  resetBtn.addEventListener("pointerup",(e)=>{ e.preventDefault(); v.reset=false; }, {passive:false});

  const soundBtn=document.getElementById("sound");
  soundBtn.addEventListener("pointerdown",(e)=>{
    e.preventDefault();
    audioOn=!audioOn;
    soundBtn.textContent = audioOn ? "üîä" : "üîá";
    beep(600,0.05,"triangle",0.04);
  }, {passive:false});

  /* ===================== Physics ===================== */
  const TILE=48;
  const FIXED_DT=1/120;
  const MAX_FRAME=1/20;

  const GRAV=2600;
  const MOVE_G=2600;
  const MOVE_A=1800;
  const AIR_CONTROL=0.62;
  const GROUND_FRICTION=0.86;
  const AIR_DAMP=0.995;

  const KG_MIN=40, KG_MAX=128, KG_START=54;
  const FART_CD=0.13;
  const WC_HOLD=1.0;

  const DOOR_L_BASE=60;
  const DOOR_H_BASE=92;
  const FAN_REQ_BASE=66;
  const CARPET_REQ_BASE=62;
  const STOMP_REQ_BASE=85;
  const BREAK_FLOOR_KG=98;

  function kg01(kg){ return clamp((kg-50)/(125-50),0,1); }
  function maxSpeed(kg){ return lerp(340,150, clamp((kg-50)/(125-50),0,1)); }
  function jumpPower(kg){ return lerp(760,420, clamp((kg-50)/(125-50),0,1)); }
  function collider(kg){ const t=kg01(kg); return { w: lerp(34, 66, t), h: lerp(44, 56, t) }; }
  function colliderSlide(kg){ const c=collider(kg); return { w:c.w, h:c.h*0.62 }; }

  /* ===================== Food defs ===================== */
  const FOOD_DEFS = [
    {id:"o", name:"Tr√† s·ªØa", kg:2, score:25,  color:"#ffb3d1"},
    {id:"c", name:"Kem",     kg:3, score:35,  color:"#cfe6ff"},
    {id:"b", name:"G√† vi√™n", kg:5, score:60,  color:"#ffd28a"},
    {id:"p", name:"Pizza",   kg:7, score:90,  color:"#ffc1a1"},
    {id:"k", name:"Burger",  kg:9, score:120, color:"#b9ffcf"},
  ];
  const FOOD_BY_ID = Object.fromEntries(FOOD_DEFS.map(d=>[d.id,d]));

  /* ===================== Themes & Levels ===================== */
  const THEMES = [
    { name:"Food City", skyA:"#7fddff", skyB:"#ffe7c8", ground:"rgba(255,200,120,0.20)" },
    { name:"Night Market", skyA:"#1a1140", skyB:"#ff6bd6", ground:"rgba(80,20,120,0.22)" },
    { name:"Bamboo Walk", skyA:"#b6ffda", skyB:"#fff2b2", ground:"rgba(150,230,170,0.16)" },
    { name:"Ice Bay", skyA:"#b7f3ff", skyB:"#ffe2f2", ground:"rgba(220,255,255,0.18)" },
    { name:"Factory", skyA:"#2b2b2f", skyB:"#ffcc66", ground:"rgba(255,190,100,0.14)" },
  ];

  const LEVELS = [
`................................................................................................................................................
................................................................................................................................................
.............o.....b........o...........p...................o...........c...........o...........b....................o.........................
....S....###########..#############..#############..#############..#############..#############..#############..############...F.............
########.#.........#..#...........#..#...........#..#....C......#..#...........#..#...........#..#....C......#..#..........#..#########
.......#.#....o....#..#..o..b..o..#..#..k..o..b..#..#...........#..#..o..c..o..#..#..p..o..b..#..#...........#..#..l..T...#..#########
.......#.#.........#..#..#####....#..#..#####....#..#....h......#..#..#####....#..#..#####....#..#....l......#..###########..#########
.......#.###########..#...........#..#...........#..#.....V.....#..#...........#..#...........#..#.....V.....#..........................
.......#..............#.....A.....#..#.....A.....#..#...........#..#.....A.....#..#....M......#..#.....A.....#..........................
.......#..............##############..#############..#############..#############..#############..#############..........................
################################################################################################################################################`,
`................................................................................................................................................
................................................................................................................................................
...........o.............c...........b.............o.............p.............o.............k.............o.............b..................
....S....###########..#############..#############..#############..#############..#############..#############..############...F.............
########.#....C....#..#...........#..#...........#..#....C......#..#...........#..#...........#..#....C......#..#..........#..#########
.......#.#.........#..#..o..b..o..#..#..k..o..b..#..#....l......#..#..o..p..o..#..#..c..o..b..#..#....h......#..#..T......#..#########
.......#.###########..#..#####....#..#..#####....#..#.....V.....#..#..#####....#..#..#####....#..#.....V.....#..###########..#########
.......#..............#.....A.....#..#.....A.....#..#.....V.....#..#.....A.....#..#.....A.....#..#.....V.....#..........................
.......#..............#....M......#..#....J......#..#....M......#..#....M......#..#....J......#..#....M......#..........................
.......#..............##############..#############..#############..#############..#############..#############..........................
################################################################################################################################################`
  ]; // (gi·ªØ 2 m√†n demo ƒë·ªÉ test UI; b·∫°n mu·ªën m√¨nh tr·∫£ l·∫°i ƒë·ªß 5 m√†n th√¨ n√≥i m√¨nh s·∫Ω paste ti·∫øp lu√¥n)

  function parseLevel(text, idx){
    const rows = text.trimEnd().split("\n");
    const ww = rows[0].length;
    const solids=[], fragile=[], spikes=[], toilets=[], checkpoints=[], foods=[], enemies=[], doorsL=[], doorsH=[], fans=[], carpets=[];
    let start={x:2*TILE,y:2*TILE};
    let finish={x:(ww-4)*TILE,y:6*TILE,w:TILE*0.8,h:TILE*1.0};

    const Lthr = DOOR_L_BASE + idx*2;
    const Hthr = DOOR_H_BASE + idx*2;
    const fanReq = FAN_REQ_BASE - idx*2;
    const carpetReq = CARPET_REQ_BASE - idx*2;
    const stompReq = STOMP_REQ_BASE + idx*2;

    for(let y=0;y<rows.length;y++){
      const row=rows[y];
      for(let x=0;x<row.length;x++){
        const ch=row[x];
        const px=x*TILE, py=y*TILE;
        if(ch==="#") solids.push({x:px,y:py,w:TILE,h:TILE});
        if(ch==="=") fragile.push({x:px,y:py,w:TILE,h:TILE,alive:true});
        if(ch==="^") spikes.push({x:px,y:py,w:TILE,h:TILE});
        if(ch==="T") toilets.push({x:px,y:py,w:TILE,h:TILE});
        if(ch==="C") checkpoints.push({x:px,y:py,w:TILE,h:TILE,used:false});
        if(ch==="V") fans.push({x:px,y:py,w:TILE,h:TILE,req:fanReq});
        if(ch==="A") carpets.push({x:px,y:py,w:TILE,h:TILE,req:carpetReq});
        if(ch==="l") doorsL.push({x:px,y:py,w:TILE,h:TILE,open:false,thr:Lthr});
        if(ch==="h") doorsH.push({x:px,y:py,w:TILE,h:TILE,open:false,thr:Hthr});
        if(ch==="S") start={x:px+6,y:py-10};
        if(ch==="F") finish={x:px+10,y:py-10,w:TILE*0.7,h:TILE*1.0};

        if(FOOD_BY_ID[ch]){
          const d=FOOD_BY_ID[ch];
          foods.push({x:px+TILE*0.2,y:py+TILE*0.25,w:TILE*0.6,h:TILE*0.5, alive:true, ...d});
        }
        if(ch==="M"){
          enemies.push({type:"walker", x:px+10,y:py-10,w:32,h:36,vx: 140*(Math.random()<0.5?-1:1), vy:0, onGround:false});
        }
        if(ch==="J"){
          enemies.push({type:"jumper", x:px+10,y:py-10,w:34,h:38,vx: 120*(Math.random()<0.5?-1:1), vy:0, onGround:false,
                        jumpCD: 0.9 + Math.random()*0.6, stompReq});
        }
      }
    }
    return {
      solids, fragile, spikes, toilets, checkpoints, foods, enemies, doorsL, doorsH, fans, carpets,
      start, finish, worldW:ww*TILE, worldH:rows.length*TILE, idx,
      thresholds:{Lthr,Hthr,fanReq,carpetReq,stompReq}
    };
  }

  /* ===================== Game state ===================== */
  let mode="menu";
  let time=0, accumulator=0, last=performance.now();
  let levelIndex=0;
  let L=parseLevel(LEVELS[levelIndex], levelIndex);
  const cam={x:0,y:0};

  const player={
    x:0,y:0,vx:0,vy:0,facing:1,
    kg:KG_START,onGround:false,jumpsLeft:3,
    isSliding:false,slideTimer:0,slideCD:0,
    onWall:0,wallGrace:0,
    fartCD:0,wcHold:0,
    invuln:0.7,dead:false,won:false,
    score:0,msg:"",msgT:0,checkpoint:null
  };
  const falling=[]; let fallTimer=0;

  function showMsg(t,sec=1.1){ player.msg=t; player.msgT=sec; }

  function resetLevel(){
    L=parseLevel(LEVELS[levelIndex], levelIndex);
    player.x=L.start.x; player.y=L.start.y;
    player.vx=0; player.vy=0; player.facing=1;
    player.kg=KG_START; player.onGround=false; player.jumpsLeft=3;
    player.isSliding=false; player.slideTimer=0; player.slideCD=0;
    player.onWall=0; player.wallGrace=0;
    player.fartCD=0; player.wcHold=0;
    player.invuln=0.75; player.dead=false; player.won=false;
    player.checkpoint={x:L.start.x,y:L.start.y};
    for(const f of L.foods) f.alive=true;
    for(const fr of L.fragile) fr.alive=true;
    for(const c of L.checkpoints) c.used=false;
    for(const d of L.doorsL) d.open=false;
    for(const d of L.doorsH) d.open=false;
    falling.length=0; fallTimer=0;
    showMsg(`M√†n ${levelIndex+1} ‚Ä¢ ${THEMES[levelIndex].name}`, 1.2);
  }
  resetLevel();

  // Tap canvas to start
  canvas.addEventListener("pointerdown",(e)=>{
    if(mode!=="menu") return;
    e.preventDefault();
    ensureAudio();
    mode="play";
    resetLevel();
    beep(660,0.06,"triangle",0.05);
  }, {passive:false});

  function getSolidBlocks(){
    const blocks=[];
    blocks.push(...L.solids);
    for(const fr of L.fragile) if(fr.alive) blocks.push({x:fr.x,y:fr.y,w:fr.w,h:fr.h, fragile:true, ref:fr});
    for(const d of L.doorsL) if(!d.open) blocks.push({x:d.x,y:d.y,w:d.w,h:d.h});
    for(const d of L.doorsH) if(!d.open) blocks.push({x:d.x,y:d.y,w:d.w,h:d.h});
    return blocks;
  }
  function pRect(){
    const c = player.isSliding ? colliderSlide(player.kg) : collider(player.kg);
    return {x:player.x,y:player.y,w:c.w,h:c.h};
  }
  function inToilet(){
    const pr=pRect();
    return L.toilets.some(t=>rects(pr,t));
  }

  function updateDoors(){
    const pr=pRect();
    const near=(d)=>rects(pr,{x:d.x-14,y:d.y-14,w:d.w+28,h:d.h+28});
    for(const d of L.doorsL){ d.open = (player.kg<=d.thr) && near(d); }
    for(const d of L.doorsH){ d.open = (player.kg>=d.thr) && near(d); }
  }

  function applyFanCarpet(dt){
    const pr=pRect();
    for(const f of L.fans){
      if(!rects(pr,f)) continue;
      const factor = (player.kg<=f.req) ? 1.0 : clamp(1-(player.kg-f.req)/40, 0.12, 1);
      player.vy -= (1650*factor)*dt;
    }
    for(const a of L.carpets){
      if(!rects(pr,a)) continue;
      if(player.vy>120){
        if(player.kg<=a.req){ player.vy=-Math.max(player.vy*0.5, 980); player.jumpsLeft=Math.max(player.jumpsLeft,2); }
        else player.vy*=0.35;
      }
    }
  }

  function moveAndCollide(dt){
    player.slideCD=Math.max(0, player.slideCD-dt);
    player.slideTimer=Math.max(0, player.slideTimer-dt);
    if(player.slideTimer<=0) player.isSliding=false;

    const col = player.isSliding ? colliderSlide(player.kg) : collider(player.kg);

    player.vy += GRAV*dt;
    if(!player.onGround) player.vx *= Math.pow(AIR_DAMP, 60*dt);

    applyFanCarpet(dt);

    // X
    player.onWall=0;
    player.x += player.vx*dt;
    let pr={x:player.x,y:player.y,w:col.w,h:col.h};
    const blocks=getSolidBlocks();
    for(const b of blocks){
      if(!rects(pr,b)) continue;
      if(player.vx>0){ player.x=b.x-col.w; player.onWall=+1; }
      else if(player.vx<0){ player.x=b.x+b.w; player.onWall=-1; }
      player.vx=0; pr.x=player.x;
    }

    // Y
    player.y += player.vy*dt;
    pr={x:player.x,y:player.y,w:col.w,h:col.h};
    player.onGround=false;
    for(const b of blocks){
      if(!rects(pr,b)) continue;
      if(player.vy>0){
        player.y=b.y-col.h; player.vy=0; player.onGround=true; player.jumpsLeft=3;
        if(b.fragile && player.kg>BREAK_FLOOR_KG){ b.ref.alive=false; player.onGround=false; player.y+=3; }
      } else if(player.vy<0){
        player.y=b.y+b.h; player.vy=0;
      }
      pr.y=player.y;
    }

    if(!player.onGround && player.onWall!==0 && player.vy>0){
      const t=kg01(player.kg);
      const maxFall=lerp(540, 380, t);
      player.vy=Math.min(player.vy, maxFall);
      player.wallGrace=0.14;
    } else player.wallGrace=Math.max(0, player.wallGrace-dt);

    if(player.y > L.worldH+260) { player.dead=true; player.msg="R∆°i kh·ªèi map üòµ"; player.msgT=2; }
  }

  function enemyStep(e,dt){
    e.vy += GRAV*dt;
    e.x += e.vx*dt;
    let er={x:e.x,y:e.y,w:e.w,h:e.h};
    const blocks=getSolidBlocks();
    for(const b of blocks){
      if(rects(er,b)){
        if(e.vx>0) e.x=b.x-e.w; else e.x=b.x+b.w;
        e.vx*=-1; er.x=e.x;
      }
    }
    e.y += e.vy*dt;
    er={x:e.x,y:e.y,w:e.w,h:e.h};
    e.onGround=false;
    for(const b of blocks){
      if(rects(er,b)){
        if(e.vy>0){ e.y=b.y-e.h; e.vy=0; e.onGround=true; }
        else if(e.vy<0){ e.y=b.y+b.h; e.vy=0; }
        er.y=e.y;
      }
    }
  }

  function eatStaticFood(){
    const pr=pRect();
    for(const f of L.foods){
      if(!f.alive) continue;
      if(rects(pr,f)){
        f.alive=false;
        player.kg=Math.min(KG_MAX, player.kg+f.kg);
        player.score+=f.score;
      }
    }
  }

  function spawnFalling(){
    const d = FOOD_DEFS[Math.floor(Math.random()*FOOD_DEFS.length)];
    const x = cam.x + 60 + Math.random()*(W()-120);
    const y = cam.y - 120 - Math.random()*160;
    falling.push({x,y,w:26,h:22,vx:(Math.random()*80-40),vy:(120+Math.random()*120),rot:0,vr:0, ...d});
    if(falling.length>70) falling.splice(0, falling.length-70);
  }
  function updateFalling(dt){
    const spawnRate = 0.55 + levelIndex*0.22;
    fallTimer += dt;
    const interval = 1/spawnRate;
    while(fallTimer>=interval){ fallTimer-=interval; spawnFalling(); }

    for(const f of falling){
      f.vy += 520*dt; f.x += f.vx*dt; f.y += f.vy*dt;
    }
    const pr=pRect();
    for(let i=falling.length-1;i>=0;i--){
      const f=falling[i];
      if(rects(pr,{x:f.x,y:f.y,w:f.w,h:f.h})){
        player.kg=Math.min(KG_MAX, player.kg+f.kg);
        falling.splice(i,1);
        continue;
      }
      if(f.y > cam.y+H()+240) falling.splice(i,1);
    }
  }

  function fart(){
    const reduce = player.kg * 0.00001;
    player.kg = Math.max(KG_MIN, player.kg - reduce);
  }
  function doToilet(){ player.kg = Math.max(KG_MIN, player.kg*0.99); }

  function drawBG(){
    const th=THEMES[levelIndex];
    const g=ctx.createLinearGradient(0,0,0,H());
    g.addColorStop(0,th.skyA);
    g.addColorStop(1,th.skyB);
    ctx.fillStyle=g; ctx.fillRect(0,0,W(),H());
    ctx.fillStyle=th.ground; ctx.fillRect(0,H()*0.60,W(),H()*0.40);
  }

  function drawWorld(){
    ctx.save(); ctx.translate(-cam.x, -cam.y);
    for(const s of L.solids){ ctx.fillStyle="#2a2a36"; ctx.fillRect(s.x,s.y,s.w,s.h); }
    for(const fr of L.fragile){ if(!fr.alive) continue; ctx.fillStyle="#3a3346"; ctx.fillRect(fr.x,fr.y,fr.w,fr.h); }
    for(const t of L.toilets){ ctx.fillStyle="#214a3a"; roundRect(t.x,t.y,t.w,t.h,12); ctx.fill(); }
    for(const d of L.doorsL){ if(d.open) continue; ctx.fillStyle="rgba(120,255,190,0.35)"; roundRect(d.x,d.y,d.w,d.h,12); ctx.fill(); }
    for(const d of L.doorsH){ if(d.open) continue; ctx.fillStyle="rgba(255,190,120,0.28)"; roundRect(d.x,d.y,d.w,d.h,12); ctx.fill(); }
    for(const f of L.foods){ if(!f.alive) continue; ctx.fillStyle=f.color; roundRect(f.x,f.y,f.w,f.h,14); ctx.fill(); }
    for(const f of falling){ ctx.fillStyle=f.color; roundRect(f.x,f.y,f.w,f.h,8); ctx.fill(); }
    // player
    const col = player.isSliding ? colliderSlide(player.kg) : collider(player.kg);
    ctx.fillStyle="#ffcfb1";
    roundRect(player.x,player.y,col.w,col.h,18); ctx.fill();
    ctx.restore();
  }

  function drawHUDText(){
    ctx.fillStyle="rgba(0,0,0,0.45)";
    roundRect(12, 12, W()-24, 62, 16); ctx.fill();
    ctx.fillStyle="#fff";
    ctx.font="900 14px system-ui";
    ctx.fillText(mode==="menu" ? "Ch·∫°m ƒë·ªÉ ch∆°i (iPhone fixed ‚Ä¢ anti-zoom)" : `KG ${player.kg.toFixed(2)} ‚Ä¢ Score ${player.score}`, 24, 38);
    if(player.msg){
      ctx.font="800 13px system-ui";
      ctx.fillText(player.msg, 24, 58);
    }
  }

  function render(){
    ctx.clearRect(0,0,W(),H());
    drawBG();
    if(mode==="play") drawWorld();
    drawHUDText();
  }

  function step(dt){
    time += dt;

    player.msgT=Math.max(0,player.msgT-dt);
    if(player.msgT<=0) player.msg="";

    if(mode!=="play" || player.dead) return;

    updateDoors();

    const left = v.left || down("a") || down("arrowleft");
    const right = v.right || down("d") || down("arrowright");
    const jump = v.jump || down("w") || down("arrowup") || down(" ");
    const slide = v.slide || down("shift");
    const fartKey = v.fart || down("f");
    const actKey  = v.act || down("e");

    const accel = player.onGround ? MOVE_G : MOVE_A*AIR_CONTROL;
    const ms = maxSpeed(player.kg);

    if(left){ player.vx -= accel*dt; player.facing=-1; }
    if(right){ player.vx += accel*dt; player.facing=+1; }
    player.vx = clamp(player.vx, -ms, ms);

    if(player.onGround && !left && !right){
      player.vx *= Math.pow(GROUND_FRICTION, 60*dt);
      if(Math.abs(player.vx)<8) player.vx=0;
    }

    if(slide && player.slideCD<=0){
      if(!player.isSliding){
        player.isSliding=true;
        player.slideTimer=0.32;
        player.slideCD=0.24;
        player.vx += 220*(player.facing||1);
      }
    }

    step.prevJump = step.prevJump ?? false;
    if(!step.prevJump && jump){
      const jp=jumpPower(player.kg);
      if(!player.onGround && (player.onWall!==0 || player.wallGrace>0)){
        const dir = (player.onWall!==0) ? -player.onWall : -(player.facing||1);
        player.vx = 420*dir;
        player.vy = -jp*0.92;
        player.facing = dir;
        player.jumpsLeft = Math.max(player.jumpsLeft,1);
      } else if(player.onGround){
        player.vy = -jp;
        player.jumpsLeft = 2;
      } else if(player.jumpsLeft>0){
        player.vy = -jp*0.90;
        player.jumpsLeft -= 1;
      }
    }
    step.prevJump = jump;

    if(fartKey && player.fartCD<=0){
      fart(); player.fartCD=FART_CD;
    }
    player.fartCD=Math.max(0, player.fartCD-dt);

    if(inToilet() && actKey){
      player.wcHold += dt;
      if(player.wcHold>=WC_HOLD){ doToilet(); player.wcHold=0; }
    } else player.wcHold=0;

    moveAndCollide(dt);
    for(const e of L.enemies) enemyStep(e,dt);
    updateFalling(dt);
    eatStaticFood();
  }

  function loop(now){
    let frame=(now-last)/1000; last=now;
    frame=Math.min(frame, MAX_FRAME);

    // reset
    if(v.reset){
      v.reset=false;
      resetLevel();
    }

    accumulator += frame;
    while(accumulator>=FIXED_DT){
      step(FIXED_DT);
      accumulator -= FIXED_DT;
    }

    // camera
    cam.x = clamp(player.x - W()*0.45, 0, Math.max(0, L.worldW - W()));
    cam.y = clamp(player.y - H()*0.55, 0, Math.max(0, L.worldH - H()));

    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>