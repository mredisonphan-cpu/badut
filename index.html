<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover"/>
<title>B√Ä ƒê·ª§T ‚Äì Upgrade v4 (Welcome + Ingame Guide + Buttons Fix + HUD Score/KG + Player Cute Bow + No Position Jump)</title>
<style>
  html,body{
    margin:0;height:100%;
    overflow:hidden;
    background:#061a2b;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
    -webkit-user-select:none; user-select:none;
    -webkit-text-size-adjust:100%;
    touch-action:none;
    overscroll-behavior:none;
    position:fixed; inset:0;
  }
  canvas{
    width:100vw;height:100vh;
    display:block;
    touch-action:none;
    background:linear-gradient(180deg,#071a2b 0%, #1a0f2f 55%, #1a0f2f 100%);
  }
  :root{
    --safeT: env(safe-area-inset-top);
    --safeR: env(safe-area-inset-right);
    --safeB: env(safe-area-inset-bottom);
    --safeL: env(safe-area-inset-left);
  }

  /* ===== HUD wrapper ===== */
  #hud{ position:fixed; inset:0; pointer-events:none; touch-action:none; }

  /* ===== Buttons base ===== */
  .btn{
    position:absolute;
    pointer-events:auto;
    display:grid; place-items:center;
    font-weight:950; color:#fff;
    border-radius:18px;
    background:rgba(30,255,214,0.18);
    border:1px solid rgba(30,255,214,0.45);
    border-bottom:2px solid rgba(255,107,155,0.35);
    backdrop-filter:blur(10px) saturate(140%);
    -webkit-backdrop-filter:blur(10px) saturate(140%);
    box-shadow:0 10px 28px rgba(0,0,0,.22);
    touch-action:none;
    user-select:none;
  }
  .btn:active{ background:rgba(255,107,155,0.25); transform:scale(.98); }

  /* ===== HUD layout: ch·ªëng ƒë√® n√∫t + g·ªçn ƒë√°y m√†n h√¨nh ===== */
  .pad{
    position:absolute;
    bottom:calc(12px + var(--safeB));
    display:flex;
    gap:10px;
    pointer-events:auto;
  }
  #padLeft{ left:calc(12px + var(--safeL)); }
  #padRight{
    right:calc(12px + var(--safeR));
    flex-direction:column;
    align-items:flex-end;
  }

  /* k√≠ch th∆∞·ªõc n√∫t m·ªõi (nh·ªè l·∫°i) */
  .btn.small{ width:58px; height:58px; font-size:22px; border-radius:16px; position:static; }
  .btn.mid  { width:96px; height:54px; font-size:14px; border-radius:16px; position:static; }
  .btn.big  { width:96px; height:76px; font-size:13px; letter-spacing:0.5px; border-radius:18px; position:static; }
  .btn.tiny { width:52px; height:40px; font-size:13px; border-radius:14px; }

  #reset{
    top:calc(12px + var(--safeT));
    right:calc(12px + var(--safeR));
    bottom:auto;
  }

  /* ===== Welcome overlay ===== */
  #welcome{
    position:fixed; inset:0;
    display:flex;
    justify-content:center;
    align-items:center;
    padding:calc(14px + var(--safeT)) calc(14px + var(--safeR)) calc(14px + var(--safeB)) calc(14px + var(--safeL));
    background:radial-gradient(1200px 700px at 50% 30%, rgba(30,255,214,0.24), rgba(0,0,0,0.78) 58%);
    color:#fff;
  }
  #welcomeCard{
    width:min(680px, 96vw);
    border-radius:22px;
    padding:16px 14px;
    background:rgba(10,42,59,0.78);
    border:1px solid rgba(30,255,214,0.35);
    box-shadow:0 16px 46px rgba(0,0,0,0.42);
    backdrop-filter:blur(12px) saturate(150%);
    -webkit-backdrop-filter:blur(12px) saturate(150%);
  }
  #welcomeTop{
    display:flex; align-items:center; gap:12px; margin-bottom:10px;
  }
  #mascot{
    width:62px; height:62px; border-radius:20px;
    background:linear-gradient(135deg, rgba(255,107,155,0.26), rgba(30,255,214,0.20));
    border:1px solid rgba(255,255,255,0.14);
    box-shadow:0 12px 26px rgba(0,0,0,0.25);
    display:grid; place-items:center;
  }
  #welcomeTitle{
    font-weight:1000;
    font-size:20px;
    margin:0;
    letter-spacing:0.3px;
  }
  #welcomeSub{
    margin:6px 0 12px;
    opacity:0.92;
    font-weight:850;
    line-height:1.35;
    font-size:13px;
  }
  #playBtn{
    margin-top:10px;
    text-align:center;
    font-weight:1000;
    font-size:15px;
    padding:12px 10px;
    border-radius:16px;
    border:1px solid rgba(30,255,214,0.60);
    background:rgba(30,255,214,0.20);
    pointer-events:auto;
  }
  #playBtn:active{ background:rgba(255,107,155,0.25); transform:scale(.99); }
  #welcomeHint{ opacity:0.85; font-weight:850; font-size:12px; margin-top:8px; text-align:center; }

  /* ===== In-game guide toast ===== */
  #guideToast{
    position:fixed;
    left:calc(12px + var(--safeL));
    right:calc(12px + var(--safeR));
    top:calc(86px + var(--safeT));
    display:none;
    pointer-events:none;
    z-index:9;
  }
  #guideToastInner{
    max-width:720px;
    margin:0 auto;
    border-radius:18px;
    padding:12px 12px;
    background:rgba(10,12,30,0.68);
    border:1px solid rgba(255,107,155,0.40);
    backdrop-filter:blur(10px) saturate(140%);
    -webkit-backdrop-filter:blur(10px) saturate(140%);
    box-shadow:0 14px 38px rgba(0,0,0,0.35);
    color:#fff;
    font-weight:900;
    font-size:13px;
    line-height:1.35;
  }
  #guideToastInner b{ color:rgba(30,255,214,0.95); }

  /* ===== End overlay ===== */
  #end{
    position:fixed; inset:0;
    display:none;
    justify-content:center;
    align-items:center;
    padding:calc(14px + var(--safeT)) calc(14px + var(--safeR)) calc(14px + var(--safeB)) calc(14px + var(--safeL));
    background:rgba(0,0,0,0.55);
    color:#fff;
  }
  #endCard{
    width:min(560px, 96vw);
    border-radius:18px;
    padding:14px;
    background:rgba(10,42,59,0.75);
    border:1px solid rgba(30,255,214,0.35);
    box-shadow:0 12px 36px rgba(0,0,0,0.35);
    backdrop-filter:blur(10px) saturate(140%);
    -webkit-backdrop-filter:blur(10px) saturate(140%);
    max-height:82vh;
    overflow:auto;
  }
  #endTitle{ font-weight:1000; font-size:18px; margin:0 0 6px; }
  #endInfo{ opacity:0.9; font-weight:800; font-size:13px; margin:0 0 12px; line-height:1.35; }
  .endBtns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
  .endBtn{
    flex:1 1 160px;
    height:46px;
    border-radius:16px;
    border:1px solid rgba(30,255,214,0.55);
    background:rgba(30,255,214,0.18);
    color:#fff;
    font-weight:1000;
    touch-action:none;
  }
  .endBtn:active{ background:rgba(255,107,155,0.25); transform:scale(.99); }
  .rankTitle{ margin:10px 0 6px; font-weight:1000; }
  .rankRow{
    display:flex; justify-content:space-between; gap:10px;
    padding:8px 10px; border-radius:12px;
    background:rgba(255,255,255,0.07);
    border:1px solid rgba(255,255,255,0.10);
    font-weight:850; font-size:12.5px; margin-bottom:6px;
  }
  .muted{ opacity:0.8; font-weight:800; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud" style="display:none;">
  <div id="padLeft" class="pad">
    <div id="left"  class="btn small">‚Üê</div>
    <div id="right" class="btn small">‚Üí</div>
  </div>

  <div id="padRight" class="pad">
    <div id="jump"  class="btn big">JUMP</div>
    <div id="fart"  class="btn mid">B·ªßm x√¨</div>
    <div id="poop"  class="btn mid">üöΩ</div>
  </div>

  <div id="reset" class="btn tiny">R</div>
</div>

<div id="welcome">
  <div id="welcomeCard">
    <div id="welcomeTop">
      <div id="mascot">
        <svg width="44" height="44" viewBox="0 0 44 44" fill="none">
          <circle cx="22" cy="22" r="18" fill="rgba(255,224,194,0.92)"/>
          <path d="M10 18 C 14 9, 30 9, 34 18" fill="rgba(43,26,59,0.95)"/>
          <circle cx="16.5" cy="21" r="2.6" fill="#0b0f1f"/>
          <circle cx="27.5" cy="21" r="2.6" fill="#0b0f1f"/>
          <path d="M16 27 C 20 31, 24 31, 28 27" stroke="rgba(122,63,43,0.95)" stroke-width="2.6" stroke-linecap="round"/>
          <circle cx="14" cy="26" r="3.2" fill="rgba(255,107,155,0.35)"/>
          <circle cx="30" cy="26" r="3.2" fill="rgba(255,107,155,0.35)"/>
        </svg>
      </div>
      <div style="flex:1">
        <div id="welcomeTitle">B√Ä ƒê·ª§T ‚Äì ƒÇn V·∫∑t & Gi·∫£m C√¢n üé∞‚ú®</div>
        <div id="welcomeSub">
          Ch∆°i vui ki·ªÉu ‚Äún√© ƒë·ªì ƒÉn r∆°i‚Äù ƒë·ªÉ <b>gi·∫£m c√¢n qua m√†n</b>.<br/>
          Ch·∫°m <b>ƒê√çCH</b> khi ‚â§60kg ƒë·ªÉ th·∫Øng. >130kg l√† thua!
        </div>
      </div>
    </div>

    <div id="playBtn">B·∫§M ƒê·ªÇ CH∆†I (b·∫≠t nh·∫°c & √¢m thanh)</div>
    <div id="welcomeHint">Tip: Gi·∫£m c√¢n th√¨ thon h∆°n & nh·∫£y cao h∆°n.</div>
  </div>
</div>

<div id="guideToast">
  <div id="guideToastInner">
    <b>H∆Ø·ªöNG D·∫™N</b><br/>
    1) N√© ƒë·ªì ƒÉn r∆°i ƒë·ªÉ l·∫•y ƒëi·ªÉm & gi·∫£m √°p l·ª±c tƒÉng c√¢n.<br/>
    2) <b>B·ªßm x√¨</b> gi·∫£m √≠t ‚Ä¢ 3) <b>üöΩ</b> gi·∫£m nhi·ªÅu (ƒë·ª©ng g·∫ßn b·ªìn c·∫ßu).
  </div>
</div>

<div id="end">
  <div id="endCard">
    <div id="endTitle">K·∫øt qu·∫£</div>
    <div id="endInfo"></div>
    <div class="rankTitle">üèÜ Ranking (Top 10 ‚Äì ch·ªâ t√≠nh khi TH·∫ÆNG)</div>
    <div id="rankList"></div>
    <div class="muted" id="bestLine"></div>
    <div class="endBtns">
      <button class="endBtn" id="againBtn">CH∆†I L·∫†I</button>
      <button class="endBtn" id="clearBtn">XO√Å RANKING</button>
    </div>
  </div>
</div>

<script>
(() => {
  /* ===== iOS: ch·ªëng zoom/scroll ===== */
  ["gesturestart","gesturechange","gestureend"].forEach(evt=>{
    document.addEventListener(evt, e=>e.preventDefault(), {passive:false});
  });
  document.addEventListener("touchmove", e=>e.preventDefault(), {passive:false});
  document.addEventListener("touchstart", (e)=>{
    if(e.touches && e.touches.length>1) e.preventDefault();
  }, {passive:false});
  let lastTap=0;
  document.addEventListener("touchend",(e)=>{
    const now=Date.now();
    if(now-lastTap<280) e.preventDefault();
    lastTap=now;
  }, {passive:false});

  /* ===== Canvas ===== */
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", {alpha:false});
  function resize(){
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener("resize", resize, {passive:true});
  resize();
  const W=()=>innerWidth, H=()=>innerHeight;

  /* ===== Audio ===== */
  let AC=null, audioOn=true, unlocked=false;
  let bgm=null;

  function ensureAudio(){
    if(!AC) AC = new (window.AudioContext||window.webkitAudioContext)();
    return AC;
  }
  function unlockAudio(){
    if(unlocked) return;
    unlocked=true;
    ensureAudio();
    if(AC.state==="suspended") AC.resume().catch(()=>{});
    sfx("ui");
    startBGM();
  }

  function startBGM(){
    if(!audioOn) return;
    if(!AC) ensureAudio();
    if(bgm) return;

    const t0 = AC.currentTime;
    const master = AC.createGain();
    master.gain.setValueAtTime(0.0001, t0);
    master.gain.linearRampToValueAtTime(0.18, t0+0.8);
    master.connect(AC.destination);

    const lp = AC.createBiquadFilter();
    lp.type="lowpass"; lp.frequency.value=1400;
    lp.connect(master);

    const lead = AC.createOscillator();
    lead.type="triangle";
    const leadGain = AC.createGain();
    leadGain.gain.value = 0.0;
    lead.connect(leadGain); leadGain.connect(lp);

    const bass = AC.createOscillator();
    bass.type="sine";
    const bassGain = AC.createGain();
    bassGain.gain.value = 0.0;
    bass.connect(bassGain); bassGain.connect(lp);

    const noiseBuf = AC.createBuffer(1, AC.sampleRate*2, AC.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.20;
    const noise = AC.createBufferSource();
    noise.buffer=noiseBuf; noise.loop=true;
    const hp = AC.createBiquadFilter();
    hp.type="highpass"; hp.frequency.value=2600;
    const noiseGain = AC.createGain();
    noiseGain.gain.value = 0.0;
    noise.connect(hp); hp.connect(noiseGain); noiseGain.connect(master);

    lead.start(t0); bass.start(t0); noise.start(t0);

    const notes = [392, 440, 523.25, 659.25, 523.25, 440];
    const bassNotes = [98, 110, 130.81, 98];
    let i=0, bi=0;

    function tick(){
      if(!bgm) return;
      const t=AC.currentTime;

      lead.frequency.setValueAtTime(notes[i%notes.length], t);
      leadGain.gain.cancelScheduledValues(t);
      leadGain.gain.setValueAtTime(leadGain.gain.value, t);
      leadGain.gain.linearRampToValueAtTime(0.06, t+0.02);
      leadGain.gain.linearRampToValueAtTime(0.00, t+0.20);

      if(i%2===0){
        bass.frequency.setValueAtTime(bassNotes[bi%bassNotes.length], t);
        bi++;
        bassGain.gain.cancelScheduledValues(t);
        bassGain.gain.setValueAtTime(bassGain.gain.value, t);
        bassGain.gain.linearRampToValueAtTime(0.05, t+0.02);
        bassGain.gain.linearRampToValueAtTime(0.0, t+0.30);
      }

      noiseGain.gain.cancelScheduledValues(t);
      noiseGain.gain.setValueAtTime(0.0, t);
      noiseGain.gain.linearRampToValueAtTime(0.02, t+0.01);
      noiseGain.gain.linearRampToValueAtTime(0.0, t+0.06);

      i++;
      bgm.timer = setTimeout(tick, 260);
    }

    bgm = {master, lp, lead, leadGain, bass, bassGain, noise, noiseGain, hp, timer:null};
    tick();
  }

  function stopBGM(){
    if(!bgm || !AC) return;
    try{
      const t=AC.currentTime;
      bgm.master.gain.cancelScheduledValues(t);
      bgm.master.gain.setValueAtTime(bgm.master.gain.value, t);
      bgm.master.gain.linearRampToValueAtTime(0.0001, t+0.25);
      if(bgm.timer) clearTimeout(bgm.timer);
      setTimeout(()=>{
        try{ bgm.lead.stop(); }catch{}
        try{ bgm.bass.stop(); }catch{}
        try{ bgm.noise.stop(); }catch{}
        bgm=null;
      }, 320);
    }catch{ bgm=null; }
  }

  function sfx(type){
    if(!audioOn) return;
    ensureAudio();
    if(AC.state==="suspended") AC.resume().catch(()=>{});
    const t=AC.currentTime;

    const mk=(oType, f0, f1, dur, g0)=>{
      const o=AC.createOscillator();
      const g=AC.createGain();
      o.type=oType;
      o.frequency.setValueAtTime(f0,t);
      if(f1) o.frequency.exponentialRampToValueAtTime(f1,t+dur*0.7);
      g.gain.setValueAtTime(g0,t);
      g.gain.exponentialRampToValueAtTime(0.001,t+dur);
      o.connect(g); g.connect(AC.destination);
      o.start(t); o.stop(t+dur);
    };
    if(type==="jump") mk("triangle", 520, 820, 0.10, 0.08);
    if(type==="eat")  mk("sine",     660, 980, 0.08, 0.06);
    if(type==="door") mk("square",   200, 120, 0.10, 0.05);
    if(type==="poop") mk("sawtooth", 160,  70, 0.14, 0.06);
    if(type==="hit")  mk("sawtooth", 240,  60, 0.16, 0.08);
    if(type==="ui")   mk("triangle", 720, 920, 0.05, 0.05);
    if(type==="warn") mk("square",   520, 260, 0.16, 0.05);
    if(type==="fart"){
      const o=AC.createOscillator();
      const g=AC.createGain();
      const f=AC.createBiquadFilter();
      o.type="square";
      o.frequency.setValueAtTime(95,t);
      f.type="lowpass";
      f.frequency.setValueAtTime(520,t);
      f.frequency.exponentialRampToValueAtTime(110,t+0.14);
      g.gain.setValueAtTime(0.06,t);
      g.gain.exponentialRampToValueAtTime(0.001,t+0.18);
      o.connect(f); f.connect(g); g.connect(AC.destination);
      o.start(t); o.stop(t+0.19);
    }
  }

  /* ===== Helpers ===== */
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rects=(a,b)=>a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;
  function rr(x,y,w,h,r){
    r=Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  /* ===== UI Buttons ===== */
  const hudEl = document.getElementById("hud");
  const V = {l:false,r:false,j:false,f:false,p:false, reset:false};

  function bindHold(id, key){
    const el=document.getElementById(id);
    const on = (e)=>{ e.preventDefault(); unlockAudio(); V[key]=true; };
    const off= (e)=>{ e.preventDefault(); V[key]=false; };
    el.addEventListener("touchstart", on, {passive:false});
    el.addEventListener("touchend", off, {passive:false});
    el.addEventListener("touchcancel", off, {passive:false});
    el.addEventListener("pointerdown", on, {passive:false});
    el.addEventListener("pointerup", off, {passive:false});
    el.addEventListener("pointercancel", off, {passive:false});
    el.addEventListener("pointerleave", off, {passive:false});
  }
  bindHold("left","l");
  bindHold("right","r");
  bindHold("jump","j");
  bindHold("fart","f");
  bindHold("poop","p");

  const resetBtn=document.getElementById("reset");
  resetBtn.addEventListener("touchstart",(e)=>{e.preventDefault(); unlockAudio(); V.reset=true;},{passive:false});
  resetBtn.addEventListener("pointerdown",(e)=>{e.preventDefault(); unlockAudio(); V.reset=true;},{passive:false});

  /* ===== Welcome ===== */
  const welcomeEl = document.getElementById("welcome");
  const playBtn = document.getElementById("playBtn");
  const guideToast = document.getElementById("guideToast");

  function showGuideToast(){
    guideToast.style.display="block";
    setTimeout(()=>{ guideToast.style.display="none"; }, 5200);
  }

  function startGameFromWelcome(e){
    e.preventDefault();
    unlockAudio();
    sfx("ui");
    welcomeEl.style.display="none";
    hudEl.style.display="block";
    mode="play";
    reset();
    showGuideToast();
  }
  playBtn.addEventListener("click", startGameFromWelcome);
  playBtn.addEventListener("touchstart", startGameFromWelcome, {passive:false});
  playBtn.addEventListener("pointerdown", startGameFromWelcome, {passive:false});

  /* ===== Ranking ===== */
  const endEl = document.getElementById("end");
  const endTitle = document.getElementById("endTitle");
  const endInfo = document.getElementById("endInfo");
  const rankList = document.getElementById("rankList");
  const bestLine = document.getElementById("bestLine");
  const againBtn = document.getElementById("againBtn");
  const clearBtn = document.getElementById("clearBtn");

  const LS_KEY="badut_ranking_v4";
  const BEST_KEY="badut_best_v4";

  function loadRanking(){ try{ return JSON.parse(localStorage.getItem(LS_KEY) || "[]"); } catch{ return []; } }
  function saveRanking(arr){ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }
  function getBest(){ return Number(localStorage.getItem(BEST_KEY) || 0); }
  function setBest(v){ localStorage.setItem(BEST_KEY, String(v)); }

  function pushRanking(entry){
    const arr=loadRanking();
    arr.push(entry);
    arr.sort((a,b)=>b.score-a.score);
    saveRanking(arr.slice(0,10));
  }
  function renderRanking(){
    const arr=loadRanking();
    rankList.innerHTML="";
    if(arr.length===0){
      rankList.innerHTML = `<div class="muted">Ch∆∞a c√≥ ai th·∫Øng ƒë·ªÉ v√†o b·∫£ng ranking.</div>`;
    }else{
      arr.forEach((e,i)=>{
        const line=document.createElement("div");
        line.className="rankRow";
        line.innerHTML = `<div>#${i+1} ‚Ä¢ ${e.name}</div><div>${Math.floor(e.score)} pts</div>`;
        rankList.appendChild(line);
      });
    }
    bestLine.textContent = `High Score (m·ªçi l∆∞·ª£t): ${Math.floor(getBest())} pts`;
  }
  function showEnd(type, reason=""){
    endEl.style.display="flex";
    renderRanking();
    if(type==="win"){
      endTitle.textContent = "üéâ TH·∫ÆNG!";
      endInfo.textContent = `B·∫°n ƒë√£ gi·∫£m c√¢n th√†nh c√¥ng! ƒêi·ªÉm: ${Math.floor(player.score)} pts ‚Ä¢ KG: ${player.kg.toFixed(2)}`;
    }else{
      endTitle.textContent = "üòµ THUA!";
      endInfo.textContent = `L√Ω do: ${reason || "Qu√° c√¢n"} ‚Ä¢ ƒêi·ªÉm: ${Math.floor(player.score)} pts ‚Ä¢ KG: ${player.kg.toFixed(2)}`;
    }
  }
  function hideEnd(){ endEl.style.display="none"; }

  againBtn.addEventListener("click",(e)=>{ e.preventDefault(); unlockAudio(); sfx("ui"); hideEnd(); mode="play"; reset(); startBGM(); showGuideToast(); });
  againBtn.addEventListener("touchstart",(e)=>{ e.preventDefault(); unlockAudio(); sfx("ui"); hideEnd(); mode="play"; reset(); startBGM(); showGuideToast(); }, {passive:false});

  clearBtn.addEventListener("click",(e)=>{ e.preventDefault(); unlockAudio(); sfx("ui"); saveRanking([]); setBest(0); renderRanking(); });
  clearBtn.addEventListener("touchstart",(e)=>{ e.preventDefault(); unlockAudio(); sfx("ui"); saveRanking([]); setBest(0); renderRanking(); }, {passive:false});

  /* ===== Food definitions ===== */
  const FOODS = [
    {id:"milk", name:"Tr√† s·ªØa",  kg:1.5},
    {id:"ice",  name:"Kem",      kg:2.5},
    {id:"nug",  name:"G√† vi√™n",  kg:4.0},
    {id:"burg", name:"Burger",   kg:6.0},
    {id:"piz",  name:"Pizza",    kg:7.5},
  ];
  function drawFoodIcon(type, x,y, s){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(s/64, s/64);

    if(type==="milk"){
      ctx.fillStyle="#ffe7f1"; rr(18,14,28,40,10); ctx.fill();
      ctx.fillStyle="#c07b55"; rr(20,28,24,24,8); ctx.fill();
      ctx.strokeStyle="#18ffd6"; ctx.lineWidth=5;
      ctx.beginPath(); ctx.moveTo(36,6); ctx.lineTo(36,26); ctx.stroke();
      ctx.fillStyle="#2b1a3b";
      for(let i=0;i<5;i++){ ctx.beginPath(); ctx.arc(24+i*8,52,3.6,0,Math.PI*2); ctx.fill(); }
    } else if(type==="ice"){
      ctx.fillStyle="#d5a56b";
      ctx.beginPath(); ctx.moveTo(32,58); ctx.lineTo(16,26); ctx.lineTo(48,26); ctx.closePath(); ctx.fill();
      ctx.fillStyle="#cfe6ff";
      ctx.beginPath(); ctx.arc(32,24,16,0,Math.PI*2); ctx.fill();
      ctx.fillStyle="#ff6b9b";
      ctx.beginPath(); ctx.arc(24,18,6,0,Math.PI*2); ctx.fill();
    } else if(type==="nug"){
      ctx.fillStyle="#ffd28a"; rr(16,20,34,26,12); ctx.fill();
      ctx.fillStyle="rgba(0,0,0,0.12)"; rr(18,22,30,22,10); ctx.fill();
      ctx.fillStyle="rgba(0,0,0,0.12)";
      for(const p of [[22,26],[34,30],[40,38],[26,40]]){
        ctx.beginPath(); ctx.arc(p[0],p[1],2.2,0,Math.PI*2); ctx.fill();
      }
    } else if(type==="burg"){
      ctx.fillStyle="#f7c97f"; rr(14,18,36,18,12); ctx.fill();
      ctx.fillStyle="#4dffb6"; rr(16,34,32,6,6); ctx.fill();
      ctx.fillStyle="#7a3f2b"; rr(16,40,32,10,6); ctx.fill();
      ctx.fillStyle="#f0b86b"; rr(14,50,36,10,8); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,0.5)";
      for(const p of [[22,22],[28,20],[36,22],[42,24]]){
        ctx.beginPath(); ctx.ellipse(p[0],p[1],3,1.6,0,0,Math.PI*2); ctx.fill();
      }
    } else if(type==="piz"){
      ctx.fillStyle="#ffd28a";
      ctx.beginPath(); ctx.moveTo(16,16); ctx.lineTo(52,30); ctx.lineTo(22,54); ctx.closePath(); ctx.fill();
      ctx.fillStyle="#ffdf6b";
      ctx.beginPath(); ctx.moveTo(20,20); ctx.lineTo(46,30); ctx.lineTo(24,48); ctx.closePath(); ctx.fill();
      ctx.fillStyle="#ff6b9b";
      for(const p of [[30,30],[36,36],[28,42]]){
        ctx.beginPath(); ctx.arc(p[0],p[1],4.4,0,Math.PI*2); ctx.fill();
      }
      ctx.strokeStyle="#f0b86b"; ctx.lineWidth=6;
      ctx.beginPath(); ctx.moveTo(16,16); ctx.lineTo(52,30); ctx.stroke();
    }
    ctx.restore();
  }

  /* ===== Toilet icon ONLY ===== */
  function drawToiletIcon(x,y,s, t){
    ctx.save();
    ctx.translate(x,y);
    const w=s, h=s;

    const glow = 0.18 + (Math.sin(t*3.2)*0.5+0.5)*0.18;
    ctx.globalAlpha=glow;
    ctx.fillStyle="rgba(30,255,214,0.9)";
    rr(-5,-5,w+10,h+10,16); ctx.fill();
    ctx.globalAlpha=1;

    ctx.fillStyle="rgba(255,255,255,0.92)";
    rr(w*0.18, h*0.08, w*0.52, h*0.26, 10); ctx.fill();
    rr(w*0.20, h*0.30, w*0.56, h*0.52, 14); ctx.fill();
    ctx.fillStyle="rgba(10,12,30,0.10)";
    rr(w*0.26, h*0.38, w*0.44, h*0.34, 14); ctx.fill();
    ctx.fillStyle="rgba(255,255,255,0.86)";
    rr(w*0.28, h*0.76, w*0.40, h*0.16, 12); ctx.fill();

    ctx.globalAlpha=0.55;
    ctx.fillStyle="rgba(255,107,155,0.9)";
    ctx.beginPath(); ctx.arc(w*0.84, h*0.20, 3.2, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle="rgba(255,255,255,0.9)";
    ctx.beginPath(); ctx.arc(w*0.78, h*0.28, 2.2, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;

    ctx.restore();
  }

  /* ===== Casino-style Exit Door ===== */
  function drawCasinoExitDoor(x,y,w,h,t){
    const blink = (Math.sin(t*6.0)*0.5+0.5);
    ctx.save();
    ctx.translate(x,y);

    ctx.globalAlpha=0.12 + blink*0.18;
    ctx.fillStyle="rgba(255,107,155,0.95)";
    rr(-18,-22,w+36,h+46,22); ctx.fill();
    ctx.globalAlpha=1;

    const bw = Math.min(280, w*4.2);
    const bx = w/2 - bw/2;
    const by = -72;

    ctx.fillStyle="rgba(10,12,30,0.75)";
    rr(bx,by,bw,46,18); ctx.fill();

    const bulbs = 18;
    for(let i=0;i<bulbs;i++){
      const px = bx + 14 + i*(bw-28)/(bulbs-1);
      const on = ((i + Math.floor(t*10)) % 3===0) ? 1 : 0;
      ctx.globalAlpha = 0.35 + on*0.45;
      ctx.fillStyle = on ? "rgba(30,255,214,0.95)" : "rgba(255,107,155,0.55)";
      ctx.beginPath(); ctx.arc(px, by+10, 4.2, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(px, by+36, 4.2, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha=1;

    ctx.fillStyle="#fff";
    ctx.font="1000 18px system-ui";
    ctx.textAlign="center";
    ctx.fillText("ƒê√çCH ƒê·∫æN", bx+bw/2, by+30);
    ctx.textAlign="left";

    const ax = w/2;
    const ay = -18;
    ctx.globalAlpha=0.55 + blink*0.35;
    ctx.fillStyle="rgba(255,255,255,0.95)";
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax-18, ay-16);
    ctx.lineTo(ax-6, ay-16);
    ctx.lineTo(ax-6, ay-34);
    ctx.lineTo(ax+6, ay-34);
    ctx.lineTo(ax+6, ay-16);
    ctx.lineTo(ax+18, ay-16);
    ctx.closePath();
    ctx.fill();
    ctx.globalAlpha=1;

    ctx.fillStyle="rgba(255,255,255,0.12)";
    rr(0,0,w,h,16); ctx.fill();
    ctx.fillStyle="rgba(30,255,214,0.16)";
    rr(8,10,w-16,h-20,14); ctx.fill();

    ctx.strokeStyle=`rgba(30,255,214,${0.35+blink*0.25})`;
    ctx.lineWidth=3;
    rr(6,6,w-12,h-12,14); ctx.stroke();

    ctx.fillStyle="rgba(255,107,155,0.9)";
    ctx.beginPath(); ctx.arc(w*0.72, h*0.56, 6, 0, Math.PI*2); ctx.fill();

    ctx.restore();
  }

  /* ===== World ===== */
  const TILE=48;

  const level = [
"#########..............................................................................o........................................................................................................",
"#................o.......o...............o........o...................................o........o.......o.......o..o..o..o..o..o...o..o..o..#.o.o.o.o.o.o.o..................TTTTTTT...............F.",
"#...............###.......##.......####################....##########............#.......####################....#############.............#......o..o..o..o................#######.o....T...........",
"#..............##........####.........................##............##...........##..........oooooooooo.....##........oooo...##...................o..o..o..............T............o....#..........#",
"#............o##.....o..##......#.......o...o...o......##T.T.T.T.T.T###..........###.........oooooooooo......##.....oooo......##...........#.........o.........T.......#............#...............#",
"#........######........##......###......#########......#################.........####............#####........###########......##.........##...................#...............o..........,...o.....#",
"#S..#.....................o...#####......o.o.o.o..o....o........................##........#....#####....................##.....oo.......................#....................................o..o...#",
"#T.###......o.......o........######################.........oooooo..............##T......###########..T...T...T...T...T.###....oo.........##..o...o..#o...o...o..o..................................#",
"#############################################################################################################################################################################################"
  ];

  const maxLen = Math.max(...level.map(r=>r.length));
  for(let i=0;i<level.length;i++){
    if(level[i].length < maxLen) level[i] = level[i] + "#".repeat(maxLen - level[i].length);
  }

  const blocks=[], foodsStatic=[], doors=[], toilets=[];
  let start={x:80,y:80}, finish={x:0,y:0,w:TILE,h:TILE};
  const worldW = maxLen * TILE;
  const worldH = level.length * TILE;

  for(let y=0;y<level.length;y++){
    const row=level[y];
    for(let x=0;x<row.length;x++){
      const ch=row[x];
      const px=x*TILE, py=y*TILE;
      if(ch==="#") blocks.push({x:px,y:py,w:TILE,h:TILE});
      if(ch==="o"){
        const def=FOODS[Math.floor(Math.random()*FOODS.length)];
        foodsStatic.push({x:px+10,y:py+10,w:30,h:30,alive:true,def});
      }
      if(ch==="D"){
        doors.push({x:px+6,y:py+2,w:TILE-12,h:TILE-4, reqKg:72, open:false});
      }
      if(ch==="T"){
        toilets.push({x:px+6,y:py+6,w:TILE-12,h:TILE-12});
      }
      if(ch==="S") start={x:px+12, y:py+6};
      if(ch==="F") finish={x:px+12,y:py+6,w:TILE,h:TILE};
    }
  }

  /* ===== FX ===== */
  const particles=[], popups=[], confetti=[];
  function spawnSparkle(x,y,count=10){
    for(let i=0;i<count;i++){
      particles.push({x,y,vx:(Math.random()*2-1)*220,vy:(Math.random()*2-1)*220-120,life:0.4+Math.random()*0.2,t:0,kind:"spark"});
    }
    if(particles.length>340) particles.splice(0,particles.length-340);
  }
  function spawnFart(x,y,dir){
    for(let i=0;i<18;i++){
      particles.push({x,y,vx:dir*(150+Math.random()*200) + (Math.random()*2-1)*60,vy:(Math.random()*2-1)*90-20,life:0.5+Math.random()*0.2,t:0,kind:"smoke"});
    }
    if(particles.length>340) particles.splice(0,particles.length-340);
  }
  function popup(text,x,y, big=false){
    popups.push({text,x,y,vy:-40,life: big?1.2:0.9, t:0, big});
    if(popups.length>40) popups.shift();
  }
  function spawnConfetti(){
    for(let i=0;i<90;i++){
      confetti.push({
        x:Math.random()*W(),
        y:-30-Math.random()*H()*0.2,
        vx:(Math.random()*2-1)*40,
        vy:60+Math.random()*90,
        rot:Math.random()*Math.PI,
        vr:(Math.random()*2-1)*4,
        s:4+Math.random()*5,
        life:1.8+Math.random()*0.8,
        t:0
      });
    }
    if(confetti.length>180) confetti.splice(0,confetti.length-180);
  }

  /* ===== Falling foods ===== */
  const falling=[]; let fallTimer=0;
  function spawnFalling(camX, camY){
    const def = FOODS[Math.floor(Math.random()*FOODS.length)];
    const x = camX + 60 + Math.random()*(W()-120);
    const y = camY - 140 - Math.random()*240;
    falling.push({
      x,y, vx:(Math.random()*2-1)*60, vy:110+Math.random()*140,
      rot:Math.random()*Math.PI, vr:(Math.random()*2-1)*2.6,
      size:26+Math.random()*10,
      def, dodged:false
    });
    if(falling.length>150) falling.splice(0, falling.length-150);
  }

  /* ===== Player ===== */
  const GRAV=2450;
  const MOVE=980;
  const MAXS=340;
  const KG_MIN=40, KG_MAX=130;
  const LOSE_KG=130;
  const TARGET_KG=60;

  const player={
    x:start.x,y:start.y,vx:0,vy:0,
    kg:55,onGround:false,
    jumps:2,
    fartCD:0,
    poopCD:0,
    score:0,
    facing:1,
    runT:0,
    blinkT:0,
    skin: { base:"#ffe0c2", hair:"#2b1a3b", name:"B√† ƒê·ª•t" },
    inAir:false,
    ateDuringAir:false
  };
  const cam={x:0,y:0};
  let mode="welcome";

  const centerMsg = {text:"", t:0, life:0, shake:0};
  function showCenter(text){
    centerMsg.text=text;
    centerMsg.t=0;
    centerMsg.life=1.25;
    centerMsg.shake=10;
    sfx("warn");
  }

  function kgT(){ return clamp((player.kg-50)/(125-50),0,1); }
  function radius(){ const t=kgT(); return 18 + t*18; }
  function jumpPower(){ const t=kgT(); return 820 - t*320; }

  /* ===== IMPORTANT: Fix ‚Äúƒë·ªïi kg b·ªã d·ªãch v·ªã tr√≠‚Äù ===== */
  function applyKg(newKg){
    const oldR = radius();
    const cx = player.x + oldR;
    const cy = player.y + oldR;

    player.kg = clamp(newKg, KG_MIN, KG_MAX);

    const newR = radius();
    player.x = cx - newR;
    player.y = cy - newR;

    player.x = clamp(player.x, 0, worldW-newR*2);
    player.y = clamp(player.y, 0, worldH-newR*2);
  }

  function reset(){
    player.x=start.x; player.y=start.y;
    player.vx=0; player.vy=0;
    player.kg=55; player.jumps=2;
    player.onGround=false;
    player.fartCD=0; player.poopCD=0;
    player.score=0;
    player.facing=1;
    player.inAir=false;
    player.ateDuringAir=false;
    for(const f of foodsStatic) f.alive=true;
    falling.length=0; particles.length=0; popups.length=0; confetti.length=0;
    for(const d of doors) d.open=false;

    const r=radius();
    player.x = clamp(player.x, 0, worldW-r*2);
    player.y = clamp(player.y, 0, worldH-r*2);

    popup("B√Ä ƒê·ª§T XU·∫§T PH√ÅT!", player.x, player.y-24, true);
  }

  function nearToilet(pr){
    for(const t of toilets){
      const near = rects(pr, {x:t.x-18,y:t.y-18,w:t.w+36,h:t.h+36});
      if(near) return t;
    }
    return null;
  }

  function lose(reason){
    if(mode!=="play") return;
    mode="end";
    stopBGM();
    sfx("hit");
    if(player.score > getBest()) setBest(player.score);
    showEnd("lose", reason);
  }
  function win(){
    if(mode!=="play") return;
    mode="end";
    stopBGM();
    sfx("door");
    if(player.score > getBest()) setBest(player.score);
    pushRanking({ name: player.skin.name, score: player.score, ts: Date.now() });
    spawnConfetti();
    showEnd("win");
  }

  function step(dt){
    if(mode!=="play") return;

    player.score += dt * 2.0;

    centerMsg.t += dt;
    if(centerMsg.t > centerMsg.life) centerMsg.life=0;
    centerMsg.shake = Math.max(0, centerMsg.shake - dt*28);

    fallTimer += dt;
    const rate=1.25;
    while(fallTimer > 1/rate){ fallTimer -= 1/rate; spawnFalling(cam.x, cam.y); }

    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.t+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=420*dt;
      if(p.t>=p.life) particles.splice(i,1);
    }
    for(let i=popups.length-1;i>=0;i--){
      const p=popups[i];
      p.t+=dt; p.y+=p.vy*dt;
      if(p.t>=p.life) popups.splice(i,1);
    }

    for(let i=confetti.length-1;i>=0;i--){
      const c=confetti[i];
      c.t+=dt; c.x+=c.vx*dt; c.y+=c.vy*dt; c.vy+=60*dt; c.rot+=c.vr*dt;
      if(c.t>=c.life) confetti.splice(i,1);
    }

    // falling foods update + dodge scoring
    for(let i=falling.length-1;i>=0;i--){
      const f=falling[i];
      f.vy += 520*dt;
      f.x += f.vx*dt;
      f.y += f.vy*dt;
      f.rot += f.vr*dt;

      const r=radius();
      const pcx=player.x+r;
      if(!f.dodged && f.y > player.y + r*2 + 10){
        const fx=f.x+f.size/2;
        if(Math.abs(fx-pcx)<120){
          f.dodged=true;
          player.score += 3;
          popup("+DODGE", fx-16, f.y-10);
        }
      }
      if(f.y > cam.y + H() + 320){
        if(!f.dodged) player.score += 2;
        falling.splice(i,1);
      }
    }

    player.fartCD=Math.max(0, player.fartCD-dt);
    player.poopCD=Math.max(0, player.poopCD-dt);

    let ax=0;
    if(V.l) ax-=MOVE;
    if(V.r) ax+=MOVE;
    if(ax!==0) player.facing = ax>0 ? 1 : -1;

    player.vx += ax*dt;
    if(!V.l && !V.r) player.vx *= Math.pow(0.82, 60*dt);
    player.vx = clamp(player.vx, -MAXS, MAXS);

    const moving=Math.abs(player.vx)>20;
    if(moving && player.onGround) player.runT += dt*(1.6 + Math.abs(player.vx)/MAXS);
    else player.runT *= 0.96;

    step.prevJ = step.prevJ ?? false;
    if(V.j && !step.prevJ && player.jumps>0){
      player.vy=-jumpPower();
      player.jumps--;
      player.inAir=true;
      player.ateDuringAir=false;
      sfx("jump");
    }
    step.prevJ = V.j;

    if(V.f && player.fartCD<=0){
      const before=player.kg;
      applyKg(player.kg*0.999);
      player.fartCD=0.12;
      if(before-player.kg>0){
        const r=radius();
        const fx=player.x+r+(player.facing>0 ? -r*0.95 : r*0.95);
        const fy=player.y+r*1.15;
        spawnFart(fx, fy, -player.facing);
        sfx("fart");
      }
    }

    player.vy += GRAV*dt;

    const r=radius();
    let pr={x:player.x,y:player.y,w:r*2,h:r*2};

    for(const d of doors){
      const near=rects(pr,{x:d.x-16,y:d.y-16,w:d.w+32,h:d.h+32});
      d.open = near && player.kg >= d.reqKg;
    }

    // X move + collisions
    player.x += player.vx*dt; pr.x=player.x;

    for(const b of blocks){
      if(!rects(pr,b)) continue;
      if(player.vx>0) player.x = b.x - pr.w;
      else if(player.vx<0) player.x = b.x + b.w;
      player.vx=0; pr.x=player.x;
    }

    for(const d of doors){
      if(d.open) continue;
      if(!rects(pr,d)) continue;
      if(player.vx>0) player.x = d.x - pr.w;
      else if(player.vx<0) player.x = d.x + d.w;
      player.vx=0; pr.x=player.x;
      popup(`·ªêM QU√Å! C·∫¶N ‚â• ${d.reqKg}KG`, d.x-30, d.y-10);
    }

    // Y move + collisions
    player.y += player.vy*dt; pr.y=player.y;
    const wasOnGround=player.onGround;
    player.onGround=false;

    for(const b of blocks){
      if(!rects(pr,b)) continue;
      if(player.vy>0){
        player.y=b.y-pr.h; player.vy=0; player.onGround=true; player.jumps=2;
      } else if(player.vy<0){
        player.y=b.y+b.h; player.vy=0;
      }
      pr.y=player.y;
    }

    if(!wasOnGround && player.onGround && player.inAir){
      if(!player.ateDuringAir){
        player.score += 2;
        popup("+CLEAN JUMP", player.x+r-24, player.y-18);
      }
      player.inAir=false;
    }

    // eat static
    for(const f of foodsStatic){
      if(!f.alive) continue;
      if(rects(pr,f)){
        f.alive=false;
        applyKg(player.kg + f.def.kg);
        spawnSparkle(f.x+14,f.y+14,10);
        popup(`+${f.def.kg}kg`, f.x, f.y-8);
        player.ateDuringAir = player.ateDuringAir || !player.onGround;
        sfx("eat");
      }
    }

    // eat falling
    for(let i=falling.length-1;i>=0;i--){
      const f=falling[i];
      if(rects(pr,{x:f.x,y:f.y,w:f.size,h:f.size})){
        applyKg(player.kg + f.def.kg);
        spawnSparkle(f.x+f.size/2,f.y+f.size/2,10);
        popup(`+${f.def.kg}kg`, f.x, f.y-8);
        player.ateDuringAir = player.ateDuringAir || !player.onGround;
        sfx("eat");
        falling.splice(i,1);
      }
    }

    // toilet
    const toilet=nearToilet(pr);
    if(toilet && V.p && player.poopCD<=0){
      const before=player.kg;
      applyKg(player.kg*0.99);
      player.poopCD=0.6;
      spawnSparkle(toilet.x+toilet.w/2, toilet.y+toilet.h/2, 14);
      popup(`-1% (${(before-player.kg).toFixed(2)}kg)`, toilet.x-10, toilet.y-12, true);
      player.score += 2;
      sfx("poop");
    } else if(!toilet && V.p){
      popup("T√åM üöΩ ƒê√É!", player.x+r-10, player.y-18);
    }

    // clamp
    player.x = clamp(player.x, 0, worldW-r*2);
    player.y = clamp(player.y, 0, worldH-r*2);

    // lose
    if(player.kg > LOSE_KG){ lose("V∆Ø·ª¢T 130KG"); return; }

    // win check
    if(rects({x:player.x,y:player.y,w:r*2,h:r*2}, finish)){
      if(player.kg <= TARGET_KG){
        win();
      } else {
        showCenter(`CH∆ØA ƒê·ª¶ ·ªêM! C·∫¶N ‚â§ ${TARGET_KG}KG`);
      }
    }
  }

  /* ===== Background ===== */
  function drawBG(t){
    const g=ctx.createLinearGradient(0,0,0,H());
    g.addColorStop(0,"#16f7d2");
    g.addColorStop(0.55,"#4b3cff");
    g.addColorStop(1,"#ff6b9b");
    ctx.fillStyle=g; ctx.fillRect(0,0,W(),H());

    ctx.save();
    ctx.globalAlpha=0.18;
    for(let i=0;i<28;i++){
      const x=(i*137 + (t*22)%700)%(W()+100)-50;
      const y=70+(i*53)%Math.max(240,H()*0.55)+Math.sin(t*1.2+i)*10;
      ctx.fillStyle=(i%3===0)?"rgba(30,255,214,0.95)":"rgba(255,107,155,0.95)";
      ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    ctx.save();
    ctx.globalAlpha=0.22;
    ctx.translate(- (cam.x*0.18)%420, 0);
    for(let i=0;i<12;i++){
      const x=i*140;
      drawBuilding(x, H()*0.42, 110, 170+(i%4)*38, "#0b0f1f");
    }
    ctx.restore();

    ctx.save();
    ctx.globalAlpha=0.30;
    ctx.translate(- (cam.x*0.32)%520, 0);
    for(let i=0;i<10;i++){
      const x=i*190;
      drawBuilding(x, H()*0.50, 150, 210+(i%4)*40, "#120a2a");
      drawNeonSign(x+24, H()*0.50+40, 80, 26, (Math.sin(t*3+i)*0.5+0.5));
    }
    ctx.restore();
  }
  function drawBuilding(x, baseY, w, h, color){
    ctx.fillStyle=color;
    rr(x, baseY, w, h, 18); ctx.fill();
    ctx.fillStyle="rgba(30,255,214,0.18)";
    for(let r=0;r<6;r++){
      for(let c=0;c<3;c++){
        const wx=x+18+c*30, wy=baseY+22+r*26;
        rr(wx,wy,16,14,4); ctx.fill();
      }
    }
  }
  function drawNeonSign(x,y,w,h,blink){
    const a=0.18+blink*0.22;
    ctx.fillStyle=`rgba(30,255,214,${a})`;
    rr(x,y,w,h,10); ctx.fill();
    ctx.strokeStyle=`rgba(255,107,155,${a+0.10})`;
    ctx.lineWidth=2;
    rr(x+2,y+2,w-4,h-4,9); ctx.stroke();
  }

  /* ===== Draw world ===== */
  function drawWorld(t){
    const r=radius();
    const cx=player.x+r, cy=player.y+r;
    cam.x = clamp(cx - W()*0.45, 0, Math.max(0, worldW - W()));
    cam.y = clamp(cy - H()*0.55, 0, Math.max(0, worldH - H()));

    ctx.save();
    ctx.translate(-cam.x, -cam.y);

    ctx.fillStyle="rgba(10,12,30,0.68)";
    for(const b of blocks) ctx.fillRect(b.x,b.y,b.w,b.h);

    for(const tt of toilets) drawToiletIcon(tt.x, tt.y, tt.w, t);

    for(const d of doors){
      ctx.fillStyle = d.open ? "rgba(30,255,214,0.14)" : "rgba(30,255,214,0.28)";
      rr(d.x,d.y,d.w,d.h,14); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,0.90)";
      ctx.font="950 12px system-ui";
      ctx.fillText(d.open ? "M·ªû" : `‚â•${d.reqKg}KG`, d.x+10, d.y+24);
    }

    for(const f of foodsStatic){
      if(!f.alive) continue;
      drawFoodIcon(f.def.id, f.x, f.y, 34);
      ctx.fillStyle="rgba(0,0,0,0.35)";
      rr(f.x, f.y-14, 46, 14, 6); ctx.fill();
      ctx.fillStyle="#fff";
      ctx.font="800 11px system-ui";
      ctx.fillText(`${f.def.kg}kg`, f.x+6, f.y-3);
    }

    for(const f of falling){
      ctx.save();
      ctx.translate(f.x+f.size/2, f.y+f.size/2);
      ctx.rotate(f.rot);
      drawFoodIcon(f.def.id, -f.size/2, -f.size/2, f.size);
      ctx.restore();
    }

    drawCasinoExitDoor(finish.x, finish.y, finish.w, finish.h, t);

    drawPlayer(t);

    for(const p of particles){
      const k=1-p.t/p.life;
      if(p.kind==="spark"){
        ctx.globalAlpha=0.75*k;
        ctx.fillStyle="rgba(255,255,255,0.9)";
        ctx.fillRect(p.x,p.y,3,3);
        ctx.fillStyle="rgba(30,255,214,0.85)";
        ctx.fillRect(p.x+3,p.y-2,2,2);
      } else {
        ctx.globalAlpha=0.35*k;
        ctx.fillStyle="rgba(255,107,155,0.75)";
        rr(p.x,p.y,10,8,6); ctx.fill();
      }
      ctx.globalAlpha=1;
    }

    for(const pp of popups){
      const k=1-pp.t/pp.life;
      ctx.globalAlpha=0.92*k;
      ctx.fillStyle="#fff";
      ctx.font = pp.big ? "1000 18px system-ui" : "950 14px system-ui";
      ctx.fillText(pp.text, pp.x, pp.y);
      ctx.globalAlpha=1;
    }

    ctx.restore();

    if(centerMsg.life>0){
      const a = 0.92 * Math.max(0, Math.min(1, (centerMsg.life-centerMsg.t)/0.35));
      const shake = centerMsg.shake>0 ? (Math.random()*2-1)*centerMsg.shake : 0;

      ctx.save();
      ctx.globalAlpha=a;
      ctx.fillStyle="rgba(10,12,30,0.75)";
      const bw=Math.min(560, W()-28), bh=76;
      rr(W()/2-bw/2+shake, H()*0.35-bh/2, bw, bh, 18); ctx.fill();
      ctx.strokeStyle="rgba(255,107,155,0.60)";
      ctx.lineWidth=2;
      rr(W()/2-bw/2+shake+2, H()*0.35-bh/2+2, bw-4, bh-4, 16); ctx.stroke();
      ctx.fillStyle="#fff";
      ctx.font="1000 18px system-ui";
      ctx.textAlign="center";
      ctx.fillText(centerMsg.text, W()/2+shake, H()*0.35+7);
      ctx.textAlign="left";
      ctx.restore();
    }
  }

  /* ===== Player: c·ª•c tr√≤n cute + m√©o nh·∫π + n∆° hoa b√™n ph·∫£i + tay r≈© + chuy·ªÉn ƒë·ªông ===== */
  function drawPlayer(t){
    const r=radius();

    const breathe = Math.sin(t*2.6)*2.2;
    const runBounce = player.onGround ? Math.sin(player.runT*10)*3 : 0;
    const sway = player.onGround ? Math.sin(player.runT*6)*0.10 : Math.sin(t*2.2)*0.06;

    ctx.save();
    ctx.translate(player.x+r, player.y+r+runBounce);

    ctx.globalAlpha=0.22;
    ctx.fillStyle="#000";
    ctx.beginPath();
    ctx.ellipse(0, r+18, r*0.95, r*0.28, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha=1;

    ctx.save();
    ctx.rotate(sway);
    const sx = 1.08, sy = 0.92;
    ctx.scale(sx, sy);

    ctx.fillStyle=player.skin.base;
    ctx.beginPath(); ctx.arc(0, breathe*0.2, r, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle="rgba(255,255,255,0.16)";
    ctx.beginPath(); ctx.ellipse(-r*0.28, -r*0.28, r*0.38, r*0.26, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle=player.skin.hair;
    rr(-r*0.78, -r*0.98, r*1.56, r*0.52, r*0.22); ctx.fill();

    ctx.fillStyle="rgba(255,107,155,0.35)";
    ctx.beginPath(); ctx.arc(-r*0.44, r*0.12, r*0.16, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*0.44, r*0.12, r*0.16, 0, Math.PI*2); ctx.fill();

    player.blinkT -= 1/60;
    if(player.blinkT<=0 && Math.random()<0.01) player.blinkT=0.12;
    const blink = player.blinkT>0;

    if(blink){
      ctx.strokeStyle="#0b0f1f";
      ctx.lineWidth=Math.max(2, r*0.10);
      ctx.beginPath();
      ctx.moveTo(-r*0.36, -r*0.12); ctx.lineTo(-r*0.18, -r*0.12);
      ctx.moveTo( r*0.18, -r*0.12); ctx.lineTo( r*0.36, -r*0.12);
      ctx.stroke();
    }else{
      ctx.fillStyle="#0b0f1f";
      ctx.beginPath(); ctx.arc(-r*0.26, -r*0.16, r*0.10, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc( r*0.26, -r*0.16, r*0.10, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle="rgba(255,255,255,0.9)";
      ctx.beginPath(); ctx.arc(-r*0.22, -r*0.20, r*0.04, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc( r*0.22, -r*0.20, r*0.04, 0, Math.PI*2); ctx.fill();
    }

    ctx.strokeStyle="#7a3f2b";
    ctx.lineWidth=Math.max(2, r*0.08);
    ctx.beginPath();
    ctx.arc(0, r*0.16, r*0.18, 0, Math.PI);
    ctx.stroke();

    ctx.restore(); // end body warp

    // tay r≈© xu·ªëng + c√≥ chuy·ªÉn ƒë·ªông
    const armSwing = player.onGround ? Math.sin(player.runT*10)*0.25 : Math.sin(t*3.0)*0.10;
    ctx.save();
    ctx.rotate(sway);

    ctx.strokeStyle="rgba(255,224,194,0.92)";
    ctx.lineWidth=Math.max(3, r*0.12);
    ctx.lineCap="round";

    ctx.beginPath();
    ctx.moveTo(-r*0.70, r*0.28);
    ctx.quadraticCurveTo(-r*0.92, r*0.62, -r*0.70, r*0.98 + armSwing*8);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(r*0.70, r*0.28);
    ctx.quadraticCurveTo(r*0.92, r*0.62, r*0.70, r*0.98 - armSwing*8);
    ctx.stroke();

    ctx.restore();

    // n∆° hoa b√™n ph·∫£i
    ctx.save();
    ctx.translate(r*0.72, -r*0.62);
    ctx.rotate(-0.25);

    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(255,107,155,0.95)";
    for(let i=0;i<5;i++){
      const ang = i*(Math.PI*2/5);
      ctx.beginPath();
      ctx.ellipse(Math.cos(ang)*6, Math.sin(ang)*6, 6, 3.8, ang, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.fillStyle="rgba(255,255,255,0.92)";
    ctx.beginPath(); ctx.arc(0,0,3.2,0,Math.PI*2); ctx.fill();

    ctx.fillStyle="rgba(30,255,214,0.80)";
    ctx.beginPath();
    ctx.moveTo(-4,6); ctx.lineTo(-14,18); ctx.lineTo(-2,14); ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(4,6); ctx.lineTo(14,18); ctx.lineTo(2,14); ctx.closePath(); ctx.fill();

    ctx.restore();

    ctx.restore();
  }

  /* ===== HUD: SCORE box + KG box (kh√¥ng ƒë√® l√™n nh√¢n v·∫≠t) ===== */
  function drawHUD(){
    // SCORE (tr√°i)
    ctx.fillStyle="rgba(30,255,214,0.14)";
    rr(12,12,220,56,16); ctx.fill();
    ctx.strokeStyle="rgba(255,107,155,0.28)";
    ctx.lineWidth=2;
    rr(14,14,216,52,15); ctx.stroke();

    ctx.fillStyle="#fff";
    ctx.font="1000 14px system-ui";
    ctx.fillText(`SCORE: ${Math.floor(player.score)}`, 26, 36);
    ctx.font="850 12px system-ui";
    ctx.fillStyle="rgba(255,255,255,0.88)";
    ctx.fillText(`Th·∫Øng khi ‚â§${TARGET_KG}kg`, 26, 54);

    // KG (k·ªÅ b√™n)
    const x2 = 12+220+10;
    ctx.fillStyle="rgba(255,107,155,0.14)";
    rr(x2,12,190,56,16); ctx.fill();
    ctx.strokeStyle="rgba(30,255,214,0.30)";
    ctx.lineWidth=2;
    rr(x2+2,14,186,52,15); ctx.stroke();

    ctx.fillStyle="#fff";
    ctx.font="1000 14px system-ui";
    ctx.fillText(`KG: ${player.kg.toFixed(2)}`, x2+14, 36);

    ctx.font="850 12px system-ui";
    ctx.fillStyle="rgba(255,255,255,0.88)";
    ctx.fillText(player.kg>LOSE_KG?`THUA: >${LOSE_KG}kg`:`Nh·∫π h∆°n = nh·∫£y cao`, x2+14, 54);
  }

  /* ===== Loop ===== */
  let last=0, acc=0;
  const FIXED=1/120, MAXF=1/20;

  function loop(ts){
    if(!last) last=ts;
    let frame=(ts-last)/1000; last=ts;
    frame=Math.min(frame, MAXF);

    if(mode==="play" && V.reset){
      V.reset=false;
      sfx("ui");
      reset();
      showGuideToast();
    }

    if(mode==="play"){
      acc += frame;
      while(acc>=FIXED){
        step(FIXED);
        acc -= FIXED;
      }
    } else {
      for(let i=confetti.length-1;i>=0;i--){
        const c=confetti[i];
        c.t+=frame; c.x+=c.vx*frame; c.y+=c.vy*frame; c.vy+=60*frame; c.rot+=c.vr*frame;
        if(c.t>=c.life) confetti.splice(i,1);
      }
    }

    const t=ts/1000;
    ctx.clearRect(0,0,W(),H());
    drawBG(t);

    if(mode==="play" || mode==="welcome"){
      // n·∫øu ƒëang welcome th√¨ ch·ªâ v·∫Ω n·ªÅn th√¥i, kh√¥ng v·∫Ω map/hud ƒë·ªÉ nh·∫π v√† s·∫°ch
      if(mode==="play"){
        drawWorld(t);
        drawHUD();
      }
    }

    requestAnimationFrame(loop);
  }

  /* ===== Start loop ===== */
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
